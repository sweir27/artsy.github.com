<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2015-04-09T13:08:05-04:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[Artsy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Culture of Openness in the Artsy Mobile Team]]></title>
    <link href="http://artsy.github.io/blog/2015/03/31/the-culture-of-openness-artsy-mobile/"/>
    <updated>2015-03-31T19:07:00-04:00</updated>
    <id>http://artsy.github.io/blog/2015/03/31/the-culture-of-openness-artsy-mobile</id>
    <content type="html"><![CDATA[<p>Recently, the Artsy Mobile team had the pleasure of working together on <a href="http://www.objc.io/issue-22/artsy.html">an article</a> for <a href="http://www.objc.io">objc.io</a>, an online publication dedicated to in-depth articles about iOS and OS X development. Each monthly issue consists of several articles centered around a theme—past issues include <a href="http://www.objc.io/issue-15/">Testing</a>, <a href="http://www.objc.io/issue-12/">Animations</a> and <a href="http://www.objc.io/issue-16/">Swift</a>. objc.io’s latest issue, <a href="http://www.objc.io/issue-22">iOS at Scale</a>, features articles by a handful of developers about how they approach iOS development at their respective companies. Our contribution to the issue is a collaboratively-written article by and about Artsy’s Mobile team from the angle of Artsy's focus on the core value of openness that is foundational to how we (and the greater Artsy team) work.</p>

<p>As our article puts it:</p>

<blockquote><p>Our team intrinsically believes in the ideas of open source. Though our individual motivations vary — from a conviction in the power of education to a determination to help others see from giants’ shoulders — we all maintain the value of open source.</p></blockquote>

<p>iOS at Artsy is characterized by a culture of open source stewardship. Although our team is small, our contributions to the Cocoa developer community are significant. We hope our article sheds some light on our development and testing practices while also providing a high-level look into our team’s philosophy. If you’d like to learn more, feel free to reach out to us at <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#109;&#111;&#98;&#x69;&#108;&#x65;&#64;&#97;&#114;&#x74;&#115;&#x79;&#x2e;&#110;&#x65;&#116;">&#109;&#x6f;&#98;&#105;&#108;&#x65;&#x40;&#x61;&#114;&#116;&#115;&#x79;&#46;&#x6e;&#x65;&#116;</a> or <a href="https://twitter.com/artsyopensource">@ArtsyOpenSource</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods-Keys and CI]]></title>
    <link href="http://artsy.github.io/blog/2015/01/21/cocoapods-keys-and-CI/"/>
    <updated>2015-01-21T16:43:00-05:00</updated>
    <id>http://artsy.github.io/blog/2015/01/21/cocoapods-keys-and-CI</id>
    <content type="html"><![CDATA[<p>We built CocoaPods-Keys as a way to remove API keys and secrets from our source code. We use it to open up our code to the pubic, without leaking private details. One of the cool things about doing it this way was that we could all use different API keys stashed away in each developers Keychain.</p>

<p>To ensure we could run CI on our apps we came up with two different ways to use keys on CI. This post explains them both.</p>

<!-- more -->


<h2>The easy way.</h2>

<p>Depending on your use-case, you may not need to use the keys at all in your testing. This works really well if you're using stubbed network requests. So if you have a keys definition in your <a href="https://github.com/artsy/eidolon/blob/9a918108e717a68a45709345f38d55e0eeb1f8b3/Podfile#L4-L21">Podfile</a> like this:</p>

<p><code>ruby
plugin 'cocoapods-keys', {
  :project =&gt; "Eidolon",
  :target =&gt; "Kiosk",
  :keys =&gt; [
    "ArtsyAPIClientSecret",
    "ArtsyAPIClientKey",
  ]
}
</code></p>

<p>Before the CI runs <code>pod install</code> you will want ensure you have already set the keys to be dummy data. So in either your <code>install:</code> or <code>before_install:</code> add commands like the following:</p>

<pre><code>    bundle exec pod keys set ArtsyAPIClientSecret "-" Eidolon
    bundle exec pod keys set ArtsyAPIClientKey "-"
</code></pre>

<p>This will set up the keys beforehand with the right target name.</p>

<h2>The fully featured way</h2>

<p>If you need to have full access to an API with secret keys, we recommend using the CI's private environment keys feature. You can see the technique being used here in Eidolon, starting on <a href="https://github.com/artsy/eidolon/blob/master/.travis.yml#L5">line 5</a> we declare a secure environment key <code>GITHUB_API_KEY</code> in that hash. Then it is used on <a href="https://github.com/artsy/eidolon/blob/aa8e8447f797c483ff72148d124d2930b58a42e7/.travis.yml#L8">line 8</a> to set up our <code>~/.netrc</code>.</p>

<p>To get started on Travis CI you will need to install the travis gem, and go through the <a href="http://docs.travis-ci.com/user/environment-variables/">Environment Variables</a> section of their documentation. Notably the <a href="http://docs.travis-ci.com/user/environment-variables/#Secure-Variables">Secure Variables</a> section. In a gist, you run <code>travis encrypt ARTSYAPICLIENTSECRET=super_secret_yo</code> and it gives you the secure string.</p>

<p>You can then use the new keys in your <code>before:</code> section:</p>

<pre><code>    bundle exec pod keys set ArtsyAPIClientSecret $ARTSYAPICLIENTSECRET Eidolon
    bundle exec pod keys set ArtsyAPIClientKey $ARTSYAPICLIENTKEY
</code></pre>

<p>That's a wrap. We don't use the second technique in any OSS repos, though there is talk of doing it on our <a href="https://github.com/artsy/Artsy_Authentication/">Artsy Authentication</a> pod. So if you're in my future 👋, maybe give that a look over as an example of the latter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPods and Frameworks]]></title>
    <link href="http://artsy.github.io/blog/2015/01/04/cocoapods-and-frameworks/"/>
    <updated>2015-01-04T16:43:00-05:00</updated>
    <id>http://artsy.github.io/blog/2015/01/04/cocoapods-and-frameworks</id>
    <content type="html"><![CDATA[<p>As I mentioned in my <a href="https://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">retrospective on Eidolon</a>, Artsy iOS codebases are often used as testbeds for new CocoaPods features. With Eidolon, we had the opportunity to try out CocoaPods' support for frameworks and Swift. This post is a look back at the month of using dependencies as dynamic frameworks instead of static libraries.</p>

<!-- more -->


<p>Updating was pretty easy: we used a <code>Gemfile</code> and <code>bundler</code> to specify a pre-release version of CocoaPods, as well as pre-release versions of its dependencies. (Updating now is easy – just run <code>[sudo] gem install cocoapods --prerelease</code> to grab the latest beta.)</p>

<p>After updating to CocoaPods, all of our existing code had to be migrated. Previously, we could import all the frameworks we used in the bridging header and they would be accessible to all of our Swift files. <a href="https://github.com/orta/eidolon/commit/abc359c55d4322d21d88349fbd044bf5b5f04725">This commit</a> is an example of having to add <code>import Moya</code> statements all throughout our Swift files that needed to access that library.</p>

<p>One by one, we created podspecs for libraries we were using. Then we would push the podspecs to a fork of that library. By specifying in our Podfile which repository CocoaPods should fetch the code from, we were able to use our own podspecs without bothering the library authors themselves. Some libraries did <a href="https://github.com/Quick/Quick/pull/197">accepted pull requests</a> to add the podspecs from us.</p>

<p>The final step to update was getting our tests to pass. Up to this point, we had added all of our classes to both the app target <em>and</em> the test target. The helpful upshot of this is that all of the test were able to access the Swift classes without us having had declared those classes <code>public</code>. Swift classes are <code>internal</code> by default, so separating out the app code from the test target required <a href="https://github.com/orta/eidolon/pull/4">quite a few</a> tedious changes throughout our codebase.</p>

<p><img src="/images/2015-01-04-cocoapods-and-frameworks/levelup.gif" alt="Level up." /></p>

<p>Eidolon is pretty distinct among iOS applications: from day one, it was developed completely in the open. Developing this kind of app in the open posed some new challenges, including limiting access to fonts for which we have licenses to use but not to distribute. Orta <a href="http://artsy.github.io/blog/2014/06/20/artsys-first-closed-source-pod/">solved this problem</a> earlier this year by having two pods: one private, and one public, but with identical header files. When installing the dependencies, CocoaPods uses one pod or the other depending on a <a href="https://github.com/artsy/eidolon/blob/4ae52f166f2d1620f25a59f36e6a87915ba32705/Podfile#L31-L35">complex heuristic</a>. However, the names of the pods are used as names for the Swift modules generated from them. Since the pods have different names, the <code>import Artsy_UIFonts</code> statements won't make sense if someone only has access to the <code>Artsy_OSSUIFonts</code> module. Swift's lack of a preprocessor led to some <a href="https://github.com/artsy/eidolon/commit/57aa66681727cfed11239f9b5a62bb59fee35f1a">hacks</a>. However, CocoaPods now allows you to specify a module name for a pod, so we'll be fixing the issue <a href="https://github.com/artsy/Artsy-OSSUIFonts/issues/1">shortly</a>.</p>

<p>Of course, Swift still has some rough edges, too. Namely, we can't compile our app with compiler optimizations enabled – the compiler will segfault. It turns out that one of our dependencies was causing the segfault – probably just a Swift compiler bug, but we needed a workaround until it's fixed. I got more familiar with post-install hooks when I dipped my toes into Ruby to <a href="https://github.com/ashfurrow/cocoapods-chillax-swift">disable the optimization on specific pods</a>.</p>

<p>Orta used the opportunity of using a prerelease version of CocoaPods to help define the new <code>plugin</code> syntax in the <a href="https://github.com/artsy/eidolon/commit/cdc8dde011e98878a7dde646d0da75c34c8fd5a9#diff-4a25b996826623c4a3a4910f47f10c30">Podfile</a>.</p>

<p>One issue that Marius covered in the <a href="http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/">CocoaPods blog post</a> is that of bundles. Since a framework is a separate bundle from the app (as opposed to a static library, which is in the same bundle), code that relies on <code>[NSBundle mainBundle]</code> isn't going to behave correctly in a framework. An unexpected problem we encountered related to bundles was our use of custom fonts. For Eidolon, our fonts reside in a CocoaPod and, therefore, now in a framework. That means that the font files aren't in our app's bundle anymore and <code>UIFont</code>'s <code>fontWithName:</code> wasn't finding those font files, regardless our use of the <code>UIAppFonts</code> key in any info.plist file. Borrowing a <a href="https://github.com/CocoaPods-Fonts/OpenSans/blob/874e65bc21abe54284e195484d2259b2fe858680/UIFont%2BOpenSans.m#L18-L38">solution from OpenSans</a>, we were able to use CoreText to load the font manually.</p>

<p>Finally, we were done.</p>

<p><img src="/images/2015-01-04-cocoapods-and-frameworks/success.gif" alt="Finally finished." /></p>

<p>Adopting CocoaPods with support for frameworks early helped us identify features and bug fixes that we could ask the CocoaPods developers for. Now, there is still time to let the team know what awesome feature you'd like to see included, but you'll have to try the fancy new CocoaPods version in order to figure out what that feature is. Sure, CocoaPods 0.36 is still in beta, but since you're already using a pre-1.0 dependency mananger, you're probably cool with trying out awesome, cutting-edge stuff. Try the new release when you get a chance and <a href="https://github.com/CocoaPods/CocoaPods/issues/new">let the team know</a> if you have feedback.</p>

<p>Our path to using CocoaPods with frameworks was bumpy, but we were the first ones to try. Today, the process is a lot easier.</p>

<p>The CocoaPods team has a <a href="http://blog.cocoapods.org/Pod-Authors-Guide-to-CocoaPods-Frameworks/">wonderful guide</a> for library authors to adopt the new CocoaPods version, so we'll likely see lots of new pods from open source Swift code, just like we already have with Objective-C.</p>

<p>A sincere thanks to <a href="http://twitter.com/mrackwitz">Marius</a> and everyone on the CocoaPods team for their dedicated work on the support for frameworks in CocoaPods.</p>

<p><img src="/images/2015-01-04-cocoapods-and-frameworks/highfive.gif" alt="Great work, team." /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Close to the Metal: Debugging Our Hardware Problem]]></title>
    <link href="http://artsy.github.io/blog/2014/11/18/debugging-our-hardware-problem/"/>
    <updated>2014-11-18T08:33:00-05:00</updated>
    <id>http://artsy.github.io/blog/2014/11/18/debugging-our-hardware-problem</id>
    <content type="html"><![CDATA[<p>For the past few months, Artsy’s mobile team has been working on <a href="https://github.com/artsy/eidolon">Eidolon</a>, a bidding kiosk for Artsy’s auctions platform. While we’ve written a <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">retrospective</a> on the process of making Eidolon from the software side of things, we didn’t really touch on how our software is being used.</p>

<!-- more -->


<p>For typical iOS applications, you create an archive with Xcode and send it to users via the Internet. Maybe it’s an App Store release that goes to Apple before being downloaded by your users. Maybe it’s a beta release that goes to <a href="http://hockeyapp.net/">Hockey</a> before being downloaded by your users. Maybe it’s an enterprise build that goes to your own servers before being downloaded by your users. In any case, there is one thing in common: your users download the software themselves and run it on their own devices.</p>

<p>Eidolon is different. We develop the software and package it using enterprise distribution and use Hockey to download it to our own iPads. These iPads are managed by the Artsy auctions team at events; they are housed in these nifty little stands which hold the iPad in place and also allow room for the credit card readers.</p>

<p><img src="/images/2014-11-18-debugging-our-hardware-problem/first_auction.jpg" alt="Eidolon at our first auction" /></p>

<p>At our first auction, everything went great – no major glitches or crashes. Awesome!</p>

<p>A few weeks later, on the morning of our second auction, things were no so great. We were having issues with our credit card processor, <a href="https://getcardflight.com">CardFlight</a> and spent a lot of time on the phone with them sorting out the problem. As a precaution, <a href="http://twitter.com/orta">Orta</a> pulled of an extraordinary feat of engineering to produce a manual card entry interface in a matter of hours. The card processing was working, but it would’ve been better to be safe than sorry.</p>

<p>That evening, the auctions team was preparing, and they discovered a problem: <em>some</em> of the Kiosks were experiencing a new problem processing cards. That was strange because earlier that day, the first issue was affecting <em>all</em> kiosks. Because we had had problems earlier that day with CardFlight, we assumed that this new problem was also on their end. We didn’t have time to debug the problem, but the event itself went fine because we had that manual entry interface. However, we definitely needed to find the cause of the problem later.</p>

<p>Orta tried over the next several days to diagnose the issue, but he couldn’t reproduce it at all. Different code, different build settings, different distribution methods – nothing could reproduce the problem.</p>

<p><img src="/images/2014-11-18-debugging-our-hardware-problem/desk.jpg" alt="Debugging the issue" /></p>

<p>Eventually, we decided that the issue must have resolved itself somehow and hopefully wouldn’t pop up again. We simply didn’t have time to keep trying to reproduce a phantom bug.</p>

<p>Fast forward to last night at the <a href="https://artsy.net/feature/ici-benefit-auction-2014">third auction</a> facilitated with Eidolon. We get there, and some of the kiosks are exhibiting the same behaviour, even though our tests earlier in the day didn’t show the problem. We tried over and over again: disassembling a problematic kiosk, discovering it worked outside the housing, then reassembling it to see it no longer working. What could the problem be?</p>

<p>Well, let’s take a look at the kiosks we used last night.</p>

<p><img src="/images/2014-11-18-debugging-our-hardware-problem/housing.jpg" alt="Kiosk housing" /></p>

<p>Notice anything different from our first auction kiosk?</p>

<p>In between the first and second auctions, the white faceplates we had ordered arrived. The auctions team put them on the Kiosks for the second auction, which is when the problem first presented. When Orta tried to reproduce the problem, the iPads he used weren’t in the housings – they were just on his desk.</p>

<p>It turned out that faceplate had some foam to provide resistance against the housing to prevent them from slipping apart. Take a look and see.</p>

<p><img src="/images/2014-11-18-debugging-our-hardware-problem/disassembled.jpg" alt="Kiosk disassembled" /></p>

<p>When the faceplate was slid onto the housing, the foam was catching on the rubber padding of the card reader (which plugs into the headphone jack of the iPad). Sliding the faceplate onto the housing was sometimes pushing the card reader a few millimetres out of the headphone jack, causing our problem.</p>

<p><img src="/images/2014-11-18-debugging-our-hardware-problem/catching.jpg" alt="The problem" /></p>

<p>The solution was simple: tear off the rubber padding from the card reader and cut off some foam from the faceplate.</p>

<p><img src="/images/2014-11-18-debugging-our-hardware-problem/solution.jpg" alt="Our solution" /></p>

<p>After that, the faceplate would slide on without issue and all of the kiosks worked fine. It took some time to disassemble all of the kiosks, but we got it working in time for the auction. Eidolon’s third performance was a success.</p>

<p>As I said earlier, Eidolon is different from typical iOS applications – our experience writing typical apps left us ill-equipped to debug what turned out to be a hardware problem. We learnt that, when reproducing bugs that only happen in production, it’s crucial to reproduce the <em>physical</em> context that the bug is occurring in as closely as possible. We also learnt that jumping to the conclusion that CardFlight was responsible for our issues was, while a natural gut reaction, deserved closer scrutiny when later trying to reproduce the problem.</p>

<p>Our auctions team was happy that we solved the phantom card-swiping problem and our users were none-the-wiser to the hurried use of Allen keys backstage to disassemble and reassmble kiosks. Eidolon, the software that we had poured so much time into, was almost defeated by a errant piece of foam. But we prevailed.</p>

<div style="text-align:center;">
<a href= "http://www.thebos.co/p/XUJNAY"><img src = "http://artsy.github.io/images/2014-11-18-debugging-our-hardware-problem/success.gif"></a>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developing a Bidding Kiosk for iOS in Swift]]></title>
    <link href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/"/>
    <updated>2014-11-13T10:00:00-05:00</updated>
    <id>http://artsy.github.io/blog/2014/11/13/eidolon-retrospective</id>
    <content type="html"><![CDATA[<p>In the Summer of 2014, we began developing a bidding kiosk for the Artsy auctions platform (code-named <a href="https://github.com/artsy/eidolon">Eidolon</a>). Typically, the iOS team here at Artsy worked on two main apps: a <a href="http://iphone.artsy.net">consumer-facing iPhone app</a> and an iPad app used by art galleries. For Eidolon, we followed <a href="https://artsy.github.io/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy/">Artsy’s standard practices</a> for building our software and use GitHub issues as our canonical source for bug reports and feature requests. Many of the components used in our apps are <a href="https://github.com/artsy">open source</a>, but the codebases themselves remain in private repositories.</p>

<p>Initial planning for Eidolon began over the Summer. Our designer <a href="http://twitter.com/katarinabatina">Katarina</a> had the main features sketched out. I was scheduled to work on it at first, with <a href="http://twitter.com/orta">Orta</a> and <a href="http://twitter.com/1aurabrown">Laura</a> joining me near the end of the project. We had a rough scope: the app would be able to list artworks at an auction and allow prospective bidders to learn more about these artworks. The user would be able to register to bid and place bids using the Kiosk, including credit card processing for identity-checking.</p>

<!-- more -->


<p><img src="/images/2014-11-12-eidolon-retrospective/listings.png" alt="Finished Eidolon App" /></p>

<h2>An Idea</h2>

<p>Orta and I met some friends over a weekend in Austria and, during our drive across the country, discussed the possibility of developing this new iOS app as a completely open source project. We were both excited about the prospect and had the support from <a href="http://twitter.com/dblockdotorg">dB</a> to make it open. There were just some technical issues that would have to be addressed to make the Kiosk app an open source reality. For example, how would we restrict access to the app’s API keys? Developing Eidolon in the open would let us share what we've learned, a value at Artsy, and also allow us to easily ask for help from the community.</p>

<p>We were also together in San Francisco for Apple’s announcement of Swift. Following the announcement, there were lots of small pieces of source code published on the Internet that demonstrated some of Swift’s new features, but a large project didn't really exist to show how iOS apps written in Swift don’t have to be moulded by outdated Objective-C traditions.</p>

<p>I wanted to write this app in Swift. After speaking with Orta, he said that as long as we could meet the deadlines, that would be okay. (Since this app uses enterprise distribution instead of the App Store, using beta versions of Xcode wouldn’t be a problem.)</p>

<p>More than just an app written in Swift, I wanted to build this app with functional reactive programming principles in mind. We would be using ReactiveCocoa any place that it made sense. While I had begun using it in our consumer iPhone app, it was mostly replacements of KVO code. This would be a fully “functionally reactive” app, a first for Orta and Laura.</p>

<p>So to summarize: our team embarked on a brand new project, developed in the open, using a new and incomplete language, built using a non-standard approach to functional programming, and using beta versions of Xcode. It was ambitious, but we were excited by the prospect of learning new things. I believed then, and do now, that Swift is the future of iOS development, and we love to be on the cutting edge (Artsy’s iOS apps are often testbeds for new CocoaPods features). There’s also an incredible demand for sample code written in Swift, so having a complete codebase written in Swift early in the language’s lifetime would be a significant contribution to the open source community.</p>

<h2>Getting Started</h2>

<p>The first steps were trivial. We examined our existing approach to iOS development and decided what techniques would be appropriate to use on this new project. Then, we identified tools that we needed to use those techniques. In some cases, existing tools needed to be modified to suit our needs. In other cases, the tools didn’t exist at all and we had to invent them.</p>

<p>Shortly after Swift’s announcement, <a href="http://twitter.com/modocache">Brian Gesiak</a> began work on <a href="https://github.com/Quick/Quick">Quick</a> and <a href="https://github.com/Quick/Nimble">Nimble</a>, a Swift-based testing framework and matchers framework, respectively. We would be able to continue using rspec-like syntax for our unit tests – awesome.</p>

<p>We use continuous integration on our other iOS projects and wanted to do the same for Eidolon. However, our usual CI provider, <a href="https://travis-ci.org">Travis</a>, has historically not supported beta versions of Xcode – our only choice for CI would be Jenkins. With a basic Swift Xcode project in hand, Orta set up Jenkins on a Mac Mini in the Artsy office. This didn’t meet our needs for a few reasons. Primarily, getting the build to work from a command line was difficult with Swift and Xcode 6 – Orta spent quite some time getting it configured. However, we all sorely missed some of the great integrations that Travis provides, particularly with GitHub. During development, we technically did have continuous integration, but it wasn’t leveraged to nearly the degree that it could or should have been.</p>

<p>A large portion of our tests on our other iOS apps rely on <a href="https://github.com/facebook/ios-snapshot-test-case">snapshot tests</a> and we use a <a href="https://github.com/dblock/ios-snapshot-test-case-expecta">set of Expecta matchers for Specta</a> that DB wrote. However, we weren’t using Specta for Eidolon and the matchers we were using wouldn’t work, so I <a href="https://github.com/AshFurrow/Nimble-Snapshots">wrote some new ones</a>. This was great from my perspective, since I didn’t really understand how the under-the-hood of a unit testing framework worked until I wrote the new matchers. It’s been fun and educational to see Quick and Nimble grow as projects. As an early adopter, the Artsy iOS team has been able to provide feedback on its development. This has hopefully helped Quick and Nimble grow in ways that benefitted from real-world use, but by contributing to the project, it also helped us get features we needed faster (you can insert either a “quick” or “swift” pun here as you wish).</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/polaroid.gif" alt="*click*" /></p>

<p>As I neared the beginning of development work on Eidolon, Orta and I discussed how we would want our networking layer to operate. One our our <a href="https://github.com/artsy/eidolon/issues/9">first GitHub issues</a> enumerated the desired features of our new network layer. In summary:</p>

<ul>
<li>Make it easy to run the app offline</li>
<li>Treat stubs as a first class citizens</li>
<li>Allow tests to state that only networking request X is allowed during this test run</li>
<li>Keep track of current requests and don't support dupes</li>
</ul>


<p>These features grew mainly out of frustrations with our ad hoc approach to network testing on our other projects: some tests would rely on stubbed models with populated data while other tests would rely on <a href="https://github.com/AliSoftware/OHHTTPStubs">stubbed network responses</a>.</p>

<p>The result of these conversations was <a href="https://github.com/AshFurrow/Moya">Moya</a>, a networking library that takes advantage of some really cool features in Swift. With some <a href="http://chris.eidhof.nl/posts/typesafe-url-routes-in-swift.html">help from Chris Eidhof</a>, we were able to write a functional-esque network abstraction library on top of <a href="https://github.com/Alamofire/Alamofire">Alamofire</a> that provided compile-time checking for API endpoints. I even wrote an optional ReactiveCocoa-based interface for Moya. This interface does not accept callback closures; instead, it returns a <em>signal</em> that represents the network request. Following <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/4403d84348b30f5ffa05dfcd6317b14e0efecc62/Documentation/FrameworkOverview.md#connections">ReactiveCocoa best-practices</a>, this signal is <em>cold</em>, meaning that until someone subscribes to it (that is, registers their interest in the network request), the request is not fetched. We were even able to write a check for duplicate, in-flight requests and return existing signals.</p>

<p>Combined with the optional ReactiveCocoa extensions, Moya succeeded in addressing all of our needs for Eidolon’s network layer. Additionally, as each project matured, the needs of a full app informed the design and development of Moya.</p>

<p>One final component that had to be addressed before main development could get underway was the issue of API keys. We wanted to have our app accessible to anyone who was interested in it, but limit access to our API keys. Keeping keys secure when they are stored near source code is closely related to the problem of keeping keys secure once an app is compiled. To <a href="http://www.quora.com/How-were-the-Twitter-iPhone-and-Android-OAuth-keys-leaked">quote John Adams</a>, a member of the Twitter Security Team:</p>

<blockquote><p>Putting this in the context of, "should you be storing keys in software", is more appropriate. Many companies do this. It's never a good idea.</p></blockquote>

<p>Over the course of a few weeks, Orta solicited some help from CocoaPods contributor <a href="http://twitter.com/segiddins">Samuel Giddins</a> to create <a href="https://github.com/orta/cocoapods-keys">cocoapods-keys</a>. This project is a <a href="http://cocoapods.org">CocoaPods</a> plugin that stores the <em>names</em> of the keys you want to use in a plaintext file in your <code>~/.cocoapods</code> directory. The <em>values</em> of the keys with matching names are stored securely in your OS X keychain. Whenever you run <code>pod install</code>, this plugin generates an obfuscated <code>char</code> array with all of your applications keys mixed up with some other random data. The keys are only un-scrambled at runtime, and the file is ignored by git. Every developer on our team has their own API keys that are stored in their OS X keychains, far away from any git repository. While using this technique by no means guarantees the security of your API keys (a dedicated hacker with a debugger attached to your running app would still be able to retrieve your keys), it’s better than nothing.</p>

<p>We began main work on the project. Orta and I divided the app into two pieces: auction listings and bid fulfillment. We created two separate storyboards that would each encapsulate one of these app components. Orta took fulfillment and I took listings – over the course of Eidolon’s development, we had very few merge conflicts.</p>

<p>We used <a href="https://github.com/paulsamuels/SBConstants">SBConstants</a> to have compile-time safety when referring to storyboard identifiers and we used Swift’s operator overloading to make using these constants <a href="https://github.com/artsy/eidolon/blob/a96763b7ccee9cd35c30079ff4044779d30e999a/Kiosk/App/UIStoryboardSegueExtensions.swift">really easy</a>. For example:</p>

<pre><code>override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
    if segue == .LoadAdminWebViewController {
        // code goes here
    }
}
</code></pre>

<p>A component that I had not developed before was an admin panel that Orta made. This panel is accessible via a hard-to-accidentally-invoke gesture within the app and is protected by a password to prevent users from accidentally accessing it. The admin panel lets you change core behaviours of the app without recompiling it. For example, the panel is used to change between production and staging.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/admin.png" alt="Admin Panel" /></p>

<p>Speaking of production and staging, to prevent developers from accidentally placing bids on production and to prevent live users from inadvertently using the staging servers, Orta made a simple badge that would let you know if you were on staging. If you were running in the simulator, it would also alert you if you were running on production. This was great, but wouldn’t prevent someone from accidentally placing bids on the production server while testing on a device. <a href="https://github.com/artsy/eidolon/blob/9181be833459307bb749df2264b3d339b371ee59/Kiosk/Auction%20Listings/ListingsViewController.swift#L157-L169">Our solution</a> was to check your current wifi network name. If it looks like you’re at the Artsy offices, then the production flag is shown, even on a device.</p>

<p>So we’ve got the scaffolding for a great app and it was time to really begin development. Using ReactiveCocoa, we were able to make our <a href="http://artsy.github.io/blog/2014/09/22/transparent-prerequisite-network-requests/">XApp authentication transparent</a>. Functional reactive programming had other great benefits, like <a href="https://github.com/artsy/eidolon/blob/9181be833459307bb749df2264b3d339b371ee59/Kiosk/Auction%20Listings/ListingsViewController.swift#L87-L137">scheduling automated refreshes</a> of auction listings. We may have <a href="https://github.com/artsy/eidolon/blob/9181be833459307bb749df2264b3d339b371ee59/Kiosk/Auction%20Listings/ListingsViewController.swift#L48-L68">gone overboard</a> in one instance (cleaning that up is on my todo list), but ReactiveCocoa has made modelling complex behaviour of Eidolon relatively easy.</p>

<p>Of course, learning how to ReactiveCocoa is no easy feat. At this point, Orta and Laura were both working on Eidolon. There were many conversations in our Slack chatroom about how to approach problem-solving the ReactiveCocoa way and, with some time, they both became proficient at creating and manipulating signals. Sweet.</p>

<p>I’ve often been asked by people who want to use ReactiveCocoa about how to get their team up to speed; until recently, I didn’t have an answer. Now that I’ve done it, I can say that the most important thing is that you realize that you’re going to be responsible for this decision. If another developer needs help using ReactiveCocoa, you’ll be the one that helps them, so take that into consideration when scheduling your work. There were also several occasions where I didn’t know the answers to the questions Orta and Laura had, but the ReactiveCocoa community was there to support us.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/clap.gif" alt="Finished Eidolon App" /></p>

<p>So what about Swift? I mean, there are other apps out there for iOS 8 and other apps that use ReactiveCocoa – how did we find Swift?</p>

<p>Well, at first it was great. We took our own approach to it, trying out new language features that were unavailable to us in Objective-C. We even did away with the usual comment header that Xcode includes in newly created files – what is that even for?</p>

<p>Progress was slow at first, but Orta and I (Laura was not yet on the project) assumed that was due to our unfamiliarity with the language. Eventually, we became relatively proficient, but our progress was still really slow. Why?</p>

<p>However ready you think the Swift language is (and however much you believe <a href="http://www.apple.com/swift/">Apple’s PR</a> about the language), the reality is that the tools necessary to use Swift are far from ready. During the Xcode 6 betas, we stayed up-to-date in the hopes that newer versions of Xcode would fix our problems. However, after the GMs were released, it became apparent that these problems would just be a reality of working in Swift.</p>

<p>What kind of problems? Certainly there were Xcode crashes, but those were mostly fixed by beta 5. Building the app with enterprise distribution certificates cost us a few days of headaches, sure. And we still can’t compile the app with compiler optimizations without causing a segfault. But what really became the bane of our existence were SourceKit crashes.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/crash.gif" alt="SourceKit Crash" /></p>

<p>When SourceKit crashes, you temporarily lose autocomplete, syntax highlighting, and the behaviour of the text editor’s shortcut keys changes dramatically. The larger your project, the more often SourceKit crashes. These crashes can last anywhere from a split second to ten seconds or more and can be alleviated using an array of cargo-cult techniques such as:</p>

<ul>
<li>deleting your derived data folder</li>
<li>restarting Xcode</li>
<li>restarting your computer</li>
<li>restarting the project from scratch using Objective-C</li>
</ul>


<p>It’s really too bad. I’ve been asking for a <a href="http://ashfurrow.com/blog/we-need-to-replace-objective-c/">replacement to Objective-C</a> for a while and, when Swift was announced, I was ecstatic. However, based on our experience using Swift in a full production app, it is our conclusion that Swift is not yet ready for use in production apps unless you are willing to take on unknown risks and delays. As much as I <em>want</em> to like Swift, I can’t make the recommendation that you should use it, even if that’s what I’d like to say. I think that Steve Streza put it best:</p>

<blockquote class="twitter-tweet" lang="en"><p>Objective-C in the streets, Swift in the sheets.</p>&mdash; Steve Streza (@SteveStreza) <a href="https://twitter.com/SteveStreza/status/474069822808915968">June 4, 2014</a></blockquote>


<p> <script async src="http://artsy.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>As we neared our deadline, we realized that we probably weren’t going to make it. This was despite Katarina dropping some features from the “must-have” list. Orta sent out an email to the auctions team letting them know the bad news and we looked at alternatives; none of them suited us. Through some late nights and weekends, and a lot of coffee and tea, the three of us were able to complete the project with only a few hours to spare. It was a herculean effort and I’m incredibly proud to have worked with Orta and Laura to make it a success.</p>

<p>The launch went fairly smoothly, with Orta on-site to assist if necessary. The auction attendees found the software easy to use – one even said that the app made bidding “too easy”, which we are incredibly proud of.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/launch.jpg" alt="Finished Eidolon App" /></p>

<p>However, this successful launch came at a cost. It was only through some very long hours and a disregard for code longevity that we were able to complete the project on time. Ignoring unit tests was fine at the time, but we now have significant technical debt that we’ll be spending the next few weeks repaying.</p>

<h2>Lessons Learned</h2>

<p>It is completely possible to write an open source iOS application, though we did have to create some tools to help us along the way. These tools are now available for everyone to use, so you should consider opening your next project from the start. We’ve adopted an “open by default” approach where we only keep things closed when we have to, like with our fonts which have restrictive licenses. If your next app isn’t a core part of what makes you you, consider having a conversation about the pros and cons of making it open source.</p>

<p>ReactiveCocoa is <em>really</em> great at networking. It forced us to use some good abstractions that we might have otherwise cut corners on. Orta describes complex signal mapping to be “too magic.” For example, you can probably figure out what the following line of code does:</p>

<pre><code>RAC(self, "artworks") &lt;~ XAppRequest(.Artworks(auctionID)).filterSuccessfulStatusCodes().mapJSON().catch { (error) -&gt; RACSignal! in
    println("Error: \(error)")
    return RACSignal.empty()
}
</code></pre>

<p>Grab some artworks with the auction ID, filter out non-successful status codes, turn the data into JSON, and if anything goes wrong with any of that, log the error and ignore the results. Then bind the result of that operation to the <code>artworks</code> property of <code>self</code>. Nice and easy.</p>

<p>We discovered, as I mentioned earlier, that Swift just isn’t ready for primetime yet. I want it to be, but it was probably a mistake to write the app in Swift. By our projections, it took us about four times longer than we had anticipated to complete the project (in terms of person-hours worked). A lot of that is admittedly due to our own faulty estimates, but a lot more of it is attributable to Swift’s immaturity. In future projects, we’re going to be more mindful about estimation.</p>

<h2>So What Now?</h2>

<p>Swift isn’t ready yet, but we already have an app written in Swift, so what do we do? We could rewrite the whole app in Objective-C, but that would represent a substantial effort with very little reward, considering that the tools surrounding Swift are expected to improve over the coming months and years. We could shift away from Swift, writing all new code in Objective-C, but a lot of the app relies on existing Swift idioms, like Moya’s compile-time safety of API endpoint checking.</p>

<p>So we’re pretty much stuck with Swift, as much as you can be “stuck” with a totally <em>awesome</em> language that just needs some more time to have a mature ecosystem of tools. Swift does, after all, address most of my concerns with Objective-C. It has a lot of features that made developing Eidolon a joy. I’m impressed with what Apple’s made so far, but I’m eagerly waiting for Xcode 6.2 and beyond.</p>

<p>On our other iOS projects, we’ll stick with Objective-C for now, but we’re starting to have conversations around what would be necessary to move to developing those in the open, too. In that respect, Eidolon has been an unqualified success.</p>

<p><img src="/images/2014-11-12-eidolon-retrospective/success.jpg" alt="Success" /></p>
]]></content>
  </entry>
  
</feed>
